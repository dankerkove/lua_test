============================
Writing an RPC Client Driver
============================

Working notes: This driver has a few shortcomings related to reliability and
performance. It should really have the following added before we go public with
this:

#. If a connection dies, we need to clean it up and probably try to re-connect
   in-place. Right now you'll probably get errors forever after the first
   connection dies.
#. SSDP search response caching. Right now each device does its own search, to
   which every device replies. So we end up with n^2 search responses at startup
   and don't even take advantage of that duplication at all.
#. A more complete description of how cosock/threading works and what users need
   to worry about. In fact the steps in this guide as written won't work as-is,
   you'll get coroutine errors from the test script step because it's using
   cosock sockets outside of a cosock thread. I want to fix this externally to
   this guide, but haven't figured out how yet.
#. Possibly a better walk through of exactly how to use the sockets' interfaces
   for those who aren't familiar with posix sockets.

This guide will help you write a SmartThings Edge Driver integrating a LAN
device that exposes a basic RPC (Remote Procedure Call) server API. This driver
will discover the device/server on the network and then act as a client to the
server.

We'll start by setting up discovery, which will use a protocol called SSDP.
This sends out a multicast packet onto your network. Your network will then send
that packet to any devices on your network that are joined to the mulitcast
group used by SSDP.

Background
----------

A Remote Procedure Call API implemented over a network connection is typically a
message passing system implemented with a request-response response model that
uses messages representing the input and output of a function call.

For our sample device, we will use an API where requests look like the
following::

    {"id":1482,"method":"setattr","params":[{"power":"off"}]}

and responses look like this::

    {"id":1482,"result":["ok"]}

Each request or response is a line of JSON text, terminated by a LF (aka "\n",
not shown).

A request includes:

1. An ID chosen by the requester, in this case a number, to identify the
   request: ``id``
2. The name of the method to be called: ``method``
3. The list of parameters to be passed to the method: ``params``

A response includes:

1. The ID from the request to allow the client to associate a response to a
   request: ``id``
2. A list of zero or more results returned from calling the method: ``results``

Essentially, this example is an RPC client telling an RPC server to run the
method ``setattr({power = "off"})`` with the RPC server responding that that
method returned one result which was ``"ok"``.

In our simple API, the ``setattr`` method is the only method that is available
to call. It takes a single parameter which is a map of attributes to set and the
values to set them to.

In addition to this request/response system, the RPC server will notify all
currently connected clients any time any client sets any attribute. In a real
world device this would allow us to update the state of a device in the
SmartThings platform when the device is controlled by some external means, such
as a manufacture's app or some scheduling system built into the device.

Notifications look like::

    {"method":"attr","params":[{"power":"off"}]}

The notification is just like a request that the client would send, except it
doesn't have an ``id`` because the server doesn't expect the client to respond.

Strategy
--------

Now that we have the protocol defined, we will discuss how to use it within the
context of a SmartThings Edge Device Driver.

This API is one of the more complicated setups to accommodate without making a
mess of our code. This is mainly due to the fact that the same socket is used
for request-response as well as async notifications. We're going to need to do
some special setup to be able to reliably handle both.

Before we can implement this, we need a device which uses the protocol outlined
above.

Tool setup
----------

This guide requires no specific hardware. Instead, we will use an external
network device simulator that you can run on your computer called `ThingSim
<https://github.com/SmartThingsCommunity/ThingSim>`_. This can be easily
installed using `LuaRocks <https://luarocks.org>`_::

    git clone git@github.com:SmartThingsCommunity/SmartThingsEdgeDriversBeta.git
    cd SmartThingsEdgeDriversBeta/examples/thingsim/
    luarocks make --local thingsim-dev-1.rockspec

    # TODO: Publish to luarocks once we can publish this in a public repo so this works:
    #luarocks install thingsim

You should now be able to run the thingsim command::

    thingsim

If it doesn't work make sure you've configured your $PATH properly for luarocks.
TODO: find or write a guide

We'll also go ahead and add a couple of things to simulate now that we'll use
later. Run ``thingsim add`` once for each simulated thing you want to add, for
example::

    thingsim add bulb --name "Imaginary Bulb #1"
    thingsim add bulb --name "Imaginary Bulb #2"

Writing a driver
----------------

The general process we're going to use for writing our driver is:

1. Write some, probably messy, code that in some way talks to your device.
2. Refactor that code into something that can be used as a library.
3. ``require`` that library into the skeleton example driver.
4. Hookup command handlers to your library's control commands.
5. Hookup attribute reporting to your library's events.


Writing a Library
---------------

The ideal way to construct a library is to write it using LuaSockets.

.. note::
  The SmartThings Platform uses a library called `cosock
  <https://github.com/cosock/cosock>`_ which allows you to write single-threaded
  blocking socket code. Behind the scenes, it interleaves different events each
  running while other events are waiting on data from the network. This means
  that you only need to write synchronous blocking network calls in each event
  handler, but do not need to worry about network calls in one event preventing
  processing in another event handler.

For our RPC library's API, let's define an interface where we can call a
function with the name of the RPC method we want to call, and have the library
handle everything else for us.

TODO: Build this step-by-step to show how sockets are used.

Here's one I whipped up earlier::

    local json = require 'dkjson'
    local socket = require "cosock".socket

    -- table that holds our module and repersents our class
    local client = { _last_req_id = 0 }

    -- `setattr` RPC
    --
    -- sets attributes on the thing
    function client:setattr(attrmap)
      local req = {
        id = self._last_req_id + 1,
        method = "setattr",
        params = {attrmap}
      }
      self._last_req_id = req.id

      return self:_call(req)
    end

    -- `getattr` RPC
    --
    -- gets the current value of attributes of thing
    function client:getattr(attrlist)
      local req = {
        id = self._last_req_id + 1,
        method = "getattr",
        params = {attrlist}
      }
      self._last_req_id = req.id

      return self:_call(req)
    end

    -- internal function that actually performs the RPC on the network
    function client:_call(call)
      local request = json.encode(call)

      local bytessent, err = self.sock:send(request.."\n")
      assert(bytessent, "failed to send request")
      assert(bytessent == #request + 1, "request only partially sent")

      while true do
        local line, err = self.sock:receive()
        assert(line, "failed to get response")
        local resp, cont, err = json.decode(line)
        assert(resp, "failed to parse response")

        if resp.id then
          assert(resp.id == call.id, "unexpected response")
          return table.unpack(resp.result)
        else
          -- a "resp" without an id is a notification, ignore for now
        end
      end
    end

    -- create a new client object
    function client.new(ip, port)
      local sock = socket.tcp()
      assert(sock:connect(ip, port))
      local o = { sock = sock, ip = ip, port = port }
      setmetatable(o, {__index = client})
      return o
    end

    return client


Don't worry if you don't understand what this code is doing. Save this code into
a file called ``rpcclient.lua`` in your driver's ``src`` directory.

To test out how this works, we'll create a file called ``call.lua`` in the
driver's ``src`` directory. The code we write here won't actually be used by the
driver.

This is the file we will write::

    local client = require "rpcclient"

    local c = client.new("127.0.0.1", 86753)

    print((c:setattr{power = "off"}))

You'll need to replace the port number (the last param) in the ``client.new``
function with the port that ThingSim tells you it has bound to.  To retrieve
that port number, we'll need to startup ThingSim with::

    thingsim run

Assuming you have at least one device added, you should see at least one line
that looks like::

   rpcserver started for 'My Thing' on 192.168.1.42:86753

If you see that message printed more than once, pick any line. Put the port
number from this (that's the number after the ``:``) in the call to
``client.new`` in the ``call.lua`` script we just created.

You'll need to leave this running for the next command and anytime you want your
driver to be accessing your devices. For any further commands that aren't
calling ``thingsim`` you'll want to open another terminal and run them there.

Now you should be able to run::

    lua call.lua

Which should output::

    ok

Congratulations, you have just controlled your simulated device from the
beginnings of your custom driver.

Discovering Things
------------------

Hard-coding an IP address might work for a one-off device, but is not an ideal
solution. We need a way of automatically finding a device on the network. Both
for initial discovery, as well as finding the address to contact of an already
added Thing even if its IP address has changed since we last talked to it.

ThingSim provides a method for doing just that. It uses a protocol called `SSDP
(Simple Service Discovery Protocol)
<https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol>`_ where it
listens for `multicast <https://en.wikipedia.org/wiki/Multicast>`_ search
requests and responds to any that denote they are looking for a "ThingSim"
device.

Below is a library file that will perform the right multicast query and wait for
any number of responses. It also parses out some custom fields like the IP
address, port, and the name of the device, if set.

::

    local socket = require("cosock").socket

    local SEARCH_RESPONSE_WAIT = 2 -- seconds, max time devices will wait before responding

    --------------------------------------------------------------------------------------------
    -- ThingSim device discovery
    --------------------------------------------------------------------------------------------

    local looking_for_all = setmetatable({}, {__index = function() return true end})

    local function process_response(val)
      local info = {}
      val = string.gsub(val, "HTTP/1.1 200 OK\r\n", "", 1)
      for k, v in string.gmatch(val, "([%g]+): ([%g ]*)\r\n") do
        info[string.lower(k)] = v
      end
      return info
    end

    local function device_discovery_metadata_generator(thing_ids, callback)
      local looking_for = {}
      local number_looking_for
      local number_found = 0
      if thing_ids ~= nil then
        number_looking_for = #thing_ids
        for _, id in ipairs(thing_ids) do looking_for[id] = true end
      else
        looking_for = looking_for_all
        number_looking_for = math.maxinteger
      end

      local s = socket.udp()
      assert(s)
      local listen_ip = interface or "0.0.0.0"
      local listen_port = 0

      local multicast_ip = "239.255.255.250"
      local multicast_port = 1900
      local multicast_msg =
      'M-SEARCH * HTTP/1.1\r\n' ..
      'HOST: 239.255.255.250:1982\r\n' ..
      'MAN: "ssdp:discover"\r\n' ..
      'MX: '..SEARCH_RESPONSE_WAIT..'\r\n' ..
      'ST: urn:smartthings-com:device:thingsim:1\r\n'

      -- Create bind local ip and port
      -- simulator will unicast back to this ip and port
      assert(s:setsockname(listen_ip, listen_port))
      -- add a second to timeout to account for network & processing latency
      local timeouttime = socket.gettime() + SEARCH_RESPONSE_WAIT + 1
      s:settimeout(8)

      local ids_found = {} -- used to filter duplicates
      assert(s:sendto(multicast_msg, multicast_ip, multicast_port))
      while number_found < number_looking_for do
        local time_remaining = math.max(0, timeouttime-socket.gettime())
        s:settimeout(time_remaining)
        local val, rip, rport = s:receivefrom()
        if val then
          log.trace(val)
          local headers = process_response(val)
          local ip, port = headers["location"]:match("http://([^,]+):([^/]+)")
          local rpcip, rpcport = (headers["rpc.smartthings.com"] or ""):match("rpc://([^,]+):([^/]+)")
          local httpip, httpport = (headers["http.smartthings.com"] or ""):match("http://([^,]+):([^/]+)")
          local id = headers["usn"]:match("uuid:([^:]+)")
          local name = headers["name.smartthings.com"]

          if rip ~= ip then
            log.warn("recieved discovery response with reported & source IP mismatch, ignoring")
          elseif ip and port and id and looking_for[id] and not ids_found[id] then
            ids_found[id] = true
                  number_found = number_found + 1
            callback({id = id, ip = ip, port = port, rpcport = rpcport, httpport = httpport, name = name})
          else
            log.debug("found device not looking for:", id)
          end
        elseif rip == "timeout" then
          return nil
        else
          error(string.format("error receving discovery replies: %s", rip))
        end
      end
    end

    local function find_cb(thing_ids, cb)
      device_discovery_metadata_generator(thing_ids, cb)
    end

    local function find(thing_ids)
      local thingsmeta = {}
      local function cb(metadata) table.insert(thingsmeta, metadata) end
      find_cb(thing_ids, cb)
      return thingsmeta
    end


    return {
      find = find,
      find_cb = find_cb,
    }

It's not important to understand everything that is happening in this library
right now. Just know that you can call the ``find`` function with an optional
list of IDs to filter on to receive a list of tables containing information
about devices that have been found, including the ``id``, the ``ip``, the
``rpcport``, and the ``name`` (if set).

This discovery library will let us update our ``call.lua`` script to discover
and control all ThingSim devices on our network. Let's update our script to look
like this::

    local client = require "rpcclient"
    local discovery = require "discovery"

    -- no filter, find all devices
    local things = discovery.find()

    -- Loop over all devices found and turn them off
    for _,thing in pairs(things) do
      local c = client.new(thing.ip, thing.rpcport)

      print((c:setattr{power = "off"}))
    end

This will send a request out to the network looking for all ThingSim type
devices; after ~3 seconds, we'll get a list of everything that has responded,
connecting to each device one-by-one and telling it to turn off.

Before we put our library to use, now is a good time to play around and try
doing a few more things with it directly to get a better understanding of what
all it can do. A few things to try:

#. Change it to turn things on.
#. Change it to toggle the things on or off (hint: try the ``getattr`` procedure).
#. Run ThingSim on one computer and your test script from another.

Turning it into a driver
------------------------

Now that we have a library that is able to interact with our Thing, let's turn
it into a SmartThings Edge Driver so that it can run on the SmartThings Hub,
take capability commands and turn them into network requests, and take network
events and turn them into capability attribute events.

We'll start with the driver from the end of the :doc:`Writing your first Lua
driver <first-driver>` guide::

    -- init.lua
    local capabilities = require "st.capabilities"
    local Driver = require "st.driver"

    local function handle_on(driver, device, command)
      log.info("Send on command to device")

      -- in most cases this should not be here, it should be
      -- code parsing messages from the device
      device:emit_event(capabilities.switch.switch.on())
    end

    local function handle_off(driver, device, command)
      log.info("Send off command to device")

      -- in most cases this should not be here, it should be
      -- code parsing messages from the device
      device:emit_event(capabilities.switch.switch.off())
    end

    -- Driver library initialization
    local example_driver =
      Driver("example_driver",
        {
          capability_handlers = {
          [capabilities.switch.ID] =
          {
            [capabilities.switch.commands.on.NAME] = handle_on,
            [capabilities.switch.commands.off.NAME] = handle_off
          }
        }
      }
    )

    -- Put other setup code here

    example_driver:run()

This skeleton driver has the basics for interfacing with the SmartThings
platform. In this section we'll be adding the code needed for interfacing with
our simulated device using the library we created.

First, we'll modify the existing capability command handler functions. In both
the handlers for "on" and for "off" we need to make sure we have an active
connection to the Thing's rpc server. Then we'll set our ``power`` attribute to
either ``on`` or ``off`` and wait for a reply to see if it worked and emitted
the corresponding switch capability attribute event.

Our on handler function will now look like this::

    local function handle_on(driver, device, command)
      log.info("switch on", device.id)

      local client = assert(get_thing_client(device))
      if client:setattr{power = "on"} then
        device:emit_event(capabilities.switch.switch.on())
      else
        log.error("failed to set power on")
      end
    end

And, similarly, our off handler function will now look like this::

    local function handle_off(driver, device, command)
      log.info("switch off", device.id)

      local client = assert(get_thing_client(device))
      if client:setattr{power = "off"} then
        device:emit_event(capabilities.switch.switch.off())
      else
        log.error("failed to set power on")
      end
    end

Let's next write a helper function for discovering a Thing and creating an
rpcclient for it. Put this as a top level function::

    -- search network for specific thing using custom discovery library
    local function find_thing(id)
      -- use our discovery function to find all of our devices
      local things = discovery.find({id})
      if not things then
        -- return early if discovery fails
        return nil
      end
      -- return the first entry in our things list
      return table.remove(thing_ids)
    end

    -- get an rpc client for thing if thing is reachable on the network
    local function get_thing_client(device)
      local thingclient = device:get_field("client")

      if not thingclient then
        local thing = find_thing(device.device_network_id)
        if thing then
          thingclient = client.new(thing.ip, thing.rpcport)
          device:set_field("client", client)

          -- tell device health to mark device online so users can control
          device:online()
        end
      end

      if not thingclient then
        -- tell device health to mark device offline so users will see that it
        -- can't currenly be controlled
        device:offline()
        return nil, "unable to reach thing"
      end

      return thingclient
    end

This function is first checking whether there is already an rpcclient handle
stored in the device; if there is, it reuses that.  If not, it performs a
network discovery searching for only our Thing by its ID.  If the Thing is
found, it uses the IP and port information to make a new client connection and
marks the device as online. If there's not an active connection and it's unable
to find it on the network, it marks our Thing as offline. It then returns the
client if one now exists.

It's helpful to abstract this out because we'll be using this in a few different
places.

The first place we'll use it is in the device initialization callback. This is
the first device lifecycle event we'll handle. First, create a dedicated
function for this callback, such as::

    -- initialize device at startup or when added
    local function device_init(driver, device)
      log.info("[" .. tostring(device.id) .. "] Initializing ThingSim RPC Client device")

      local client = get_thing_client(device)

      if client then
        log.info("Connected")
      else
        log.warn(
          "Device not found at initial discovery (no async events until controlled)",
          device:get_field("name") or device.device_network_id
        )
      end
    end

This calls our full-featured discovery function to see if anything was found. We
can be confident that nothing was already saved because this handler is only
ever called by the underlying system when a new ``Device`` is created, either at
driver startup or when a new device is added.

Now we will add another handler for when a new device is added. All we're going
to do is log, but this can be helpful for debugging::

    -- handle setup for newly added devices (before device_init)
    local function device_added(driver, device)
      log.info("[" .. tostring(device.id) .. "] New ThingSim RPC Client device added")
    end

To actually use these handlers we'll need to add them to our driver handers
table. Here we've added the ``lifecycle_handlers`` table::

    local example_driver =
      Driver("example_driver",
        {
          lifecycle_handlers = {
            added = device_added,
            init = device_init,
          },
          capability_handlers = {
          [capabilities.switch.ID] =
          {
            [capabilities.switch.commands.on.NAME] = handle_on,
            [capabilities.switch.commands.off.NAME] = handle_off
          }
        }
      }
    )

Now our driver works for any device that's already added. But we have no way to
add devices yet. Let's add a discovery handler::

    -- discover not already known devices listening on the network
    local function discovery_handler(driver, options, should_continue)
      log.info("starting discovery")
      local known_devices = {}
      local found_devices = {}

      local device_list = devices.get_device_list()
      for i, device_uuid in ipairs(device_list) do
        local device = driver:get_device_info(device_uuid)
        local id = device.device_network_id
        known_devices[id] = true
      end

      while should_continue() do
        log.info("making discovery request")
        discovery.find_cb(
          nil, -- find all things
          function(device)
            local id = device.id
            local ip = device.ip
            local name = device.name or "Unnamed ThingSim RPC Client"

            if not known_devices[id] and not found_devices[id] then
              found_devices[id] = true
              log.info(string.format("adding %s at %s", name or id, ip))
              assert(
                devices.create_device(json.encode({
                  type = "LAN",
                  deviceNetworkId = id,
                  label = name,
                  parentDeviceId = nil,
                  profileReference = "thingsim.onoff.v1",
                  manufacturer = "thingsim",
                  model = "On/Off Bulb",
                  vendorProvidedName = name
                })),
                "failed to send found_device"
              )
            end
          end
        )
      end
      log.info("exiting discovery")
    end

Just like before, add this handler to our driver's list of handlers inserting
this again at the top level::

    discovery = discovery_handler,

And with that our basic driver is complete! Your ``init.lua`` file should now
look something like this::

    -- smartthings libraries
    local capabilities = require "st.capabilities"
    local Driver = require "st.driver"

    -- the coroutine runtime's socket interface
    local socket = require "cosock".socket

    -- driver specific libraries from this repo
    local client = require "rpcclient"
    local discovery = require "discovery"

    -- required for temporary use of internal device create API
    local json = require "dkjson"

    --------------------------------------------------------------------------------
    -- Local Helpers
    --------------------------------------------------------------------------------

    -- search network for specific thing using custom discovery library
    --
    -- TODO: make this more efficient, this currently sends out an SSDP broadcast for
    -- each thing, we should coalesce these to just send out a single request for the
    -- whole driver
    local function find_thing(id)
      -- use our custom discovery function to find the device with the specified ID
      local things = discovery.find({id})
      if not things then
        -- return early if discovery fails
        return nil
      end
      -- return the first (and presumably only) thing we found
      return table.remove(things)
    end

    -- get an rpc client for thing if thing is reachable on the network
    local function get_thing_client(device)
      local thingclient = device:get_field("client")

      if not thingclient then
        local thing = find_thing(device.device_network_id)
        if thing then
          thingclient = client.new(thing.ip, thing.rpcport)
          device:set_field("client", client)

          -- tell device health to mark device online so users can control
          device:online()
        end
      end

      if not thingclient then
        -- tell device health to mark device offline so users will see that it
        -- can't currenly be controlled
        device:offline()

        return nil, "unable to reach thing"
      end

      return thingclient
    end

    --------------------------------------------------------------------------------
    -- Device and Driver Event Handlers
    --------------------------------------------------------------------------------

    -- handle setup for newly added devices (before device_init)
    local function device_added(driver, device)
      log.info("["..tostring(device.id).."] New ThingSim RPC Client device added")

      -- nothing to do here, everything happens in init this is just here for
      -- completeness, if you don't need this callback you can remove it
    end

    -- initialize device at startup or when added
    local function device_init(driver, device)
      log.info("["..tostring(device.id).."] Init ThingSim RPC Client device")

      local thing = find_thing(device.device_network_id)

      if thing then
        local c = client.new(thing.ip, thing.rpcport)

        device:set_field("client", c)
        log.info("Connected")
      else
        log.warn(
          "Device not found at initial discovery (no async events until controlled)",
          device:get_field("name") or device.device_network_id
        )
      end
    end

    -- discover not already known devices listening on the network
    local function discovery_handler(driver, options, should_continue)
      log.info("starting discovery")
      local known_devices = {}
      local found_devices = {}

      local device_list = devices.get_device_list()
      for i, device_uuid in ipairs(device_list) do
        local device = driver:get_device_info(device_uuid)
        local id = device.device_network_id
        known_devices[id] = true
      end

      while should_continue() do
        log.info("making discovery request")
        discovery.find_cb(
          nil, -- find all things
          function(device)
            local id = device.id
            local ip = device.ip
            local name = device.name or "Unnamed ThingSim RPC Client"

            if not known_devices[id] and not found_devices[id] then
              found_devices[id] = true
              log.info(string.format("adding %s at %s", name or id, ip))
              assert(
                devices.create_device(json.encode({
                  type = "LAN",
                  deviceNetworkId = id,
                  label = name,
                  parentDeviceId = nil,
                  profileReference = "thingsim.onoff.v1",
                  manufacturer = "thingsim",
                  model = "On/Off Bulb",
                  vendorProvidedName = name
                })),
                "failed to send found_device"
              )
            end
          end
        )
      end
      log.info("exiting discovery")
    end

    --------------------------------------------------------------------------------
    -- Command Handlers
    --------------------------------------------------------------------------------

    function handle_switch_on(driver, device, somethingmaybe)
      log.info("switch on", device.id)

      local client = assert(get_thing_client(device))
      if client:setattr{power = "on"} then
        device:emit_event(capabilities.switch.switch.on())
      else
        log.error("failed to set power on")
      end
    end

    function handle_switch_off(driver, device, somethingmaybe)
      log.info("switch off", device.id)

      local client = assert(get_thing_client(device))
      if client:setattr{power = "off"} then
        device:emit_event(capabilities.switch.switch.off())
      else
        log.error("failed to set power on")
      end
    end

    --------------------------------------------------------------------------------
    -- Build and Run Driver
    --------------------------------------------------------------------------------

    local rpc_client_driver = Driver("rpc client",
      {
        discovery = discovery_handler,
        lifecycle_handlers = {
          added = device_added,
          init = device_init,
        },
        capability_handlers = {
          [capabilities.switch.ID] = {
            [capabilities.switch.commands.on.NAME] = handle_switch_on,
            [capabilities.switch.commands.off.NAME] = handle_switch_off
          },
        }
      }
    )

    rpc_client_driver.bulb_handles = {}

    rpc_client_driver:run()

Next, publish & install your new driver using the `SmartThings CLI
<https://github.com/SmartThingsCommunity/smartthings-cli>`_, make sure the
ThingSim daemon is running; if not ,run it with ``thingsim run`` and perform a
"Scan Nearby" in the SmartThings app. Your ThingSim Things should pop up moments
after you start.

Congratulations, you have now written your own SmartThings Edge Driver,
installed it on a Hub, and put it to use. You now know everything needed to
write a SmartThings Edge Driver for any LAN device that exposes a similar API.
