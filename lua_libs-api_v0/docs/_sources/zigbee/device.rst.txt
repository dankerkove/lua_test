ZigbeeDevice Class
==================

This is a class that inherits from the :lua:class:`Device <Device>` class, but extends behavior
with Zigbee-specific functionality.  These functions are documented in the class documentation below.

Multi-Component devices
+++++++++++++++++++++++

There are a number of situations where the SmartThings model of the device makes sense to be broken down into several
"components".  A classic example of this would be a smart power strip, where it is a single device on the network, but
each outlet can be controlled separately.  This would best be modeled as a single device, with a component for each
switch.  See the TODO: SmartThings Profile documentation for more discussion on SmartThings components.
Within Zigbee these separate pieces of functionality are often modeled as "endpoints", and messages to the devices can
be addressed to the specific endpoint you want to control and interact with.  In order to promote code reuse the
ZigbeeDevice object provides a way for your driver to define how you want to map between components and endpoints that
can then be used by the rest of the Zigbee Lua standard library to automatically generate events for the correct
components or send messages to the correct endpoint.  As an important note, as with most things in the standard library
this is built to support the most common model, but it is likely that there will be individual devices that don't
adhere to this model and will need to override this behavior.

In order to opt in to this behavior you can use the following functions:

.. code-block:: lua

    function ZigbeeDevice:set_component_to_endpoint_fn(comp_ep_fn)
    function ZigbeeDevice:set_endpoint_to_component_fn(ep_comp_fn)


Here you can provide a function for each direction to map a Zigbee endpoint id (1 byte number) to a SmartThings
component id (string), and vice versa.  Once these are set the following functions on the device are used for event
generation and message addressing:

.. code-block:: lua

   function ZigbeeDevice:get_endpoint_for_component_id(comp_id)
   function ZigbeeDevice:get_component_id_for_endpoint(ep)


If these functions are used without settign the mapping functions above, they will return the defaults ("main" for a
component, and ``device.fingerprinted_endpoint_id`` for the endpoint).  Further as a convenience method the following
function is provided as well

.. code-block:: lua

    function ZigbeeDevice:emit_event_for_endpoint(endpoint, event)


That will automatically generate the event for the correct endpoint.

example
~~~~~~~

Here is a simple example of a driver that supports multi switch Zigbee outlet where the profiles are defined as follows:

.. code-block:: yaml

    name: two-outlet
    components:
    - id: main
      capabilities:
      - id: switch
        version: 1
      categories:
      - name: Switch
    - id: switch1
      capabilities:
      - id: switch
        version: 1
      categories:
      - name: Switch

    name: three-outlet
    components:
    - id: main
      capabilities:
      - id: switch
        version: 1
      categories:
      - name: Switch
    - id: switch1
      capabilities:
      - id: switch
        version: 1
      categories:
      - name: Switch
    - id: switch2
      capabilities:
      - id: switch
        version: 1
      categories:
      - name: Switch


And uses Zigbee endpoints ``0x00`` for the first outlet and increments by one for each additional outlet.  Then the
following driver will be able to use the builtin behavior to correctly generate events and address commands.


.. code-block:: lua

    local capabilities = require "st.capabilities"
    local ZigbeeDriver = require "st.zigbee"
    local defaults = require "st.zigbee.defaults"

    local function component_to_endpoint(device, component_id)
      if component_id == "main" then
        return device.fingerprinted_endpoint_id
      else
        local ep_num = component_id:match("switch(%d)")
        return ep_num and tonumber(ep_num) or device.fingerprinted_endpoint_id
      end
    end

    local function endpoint_to_component(device, ep)
      if ep == device.fingerprinted_endpoint_id then
        return "main"
      else
        return string.format("switch%d", ep)
      end
    end

    local device_init = function(self, device)
      device:set_component_to_endpoint_fn(component_to_endpoint)
      device:set_endpoint_to_component_fn(endpoint_to_component)
    end

    local zigbee_outlet_driver_template = {
      supported_capabilities = {
        capabilities.switch,
      },
      lifecycle_handlers = {
        init = device_init,
      },
    }

    defaults.register_for_default_handlers(zigbee_outlet_driver_template, zigbee_outlet_driver_template.supported_capabilities)
    local zigbee_outlet = ZigbeeDriver("zigbee_bulb", zigbee_outlet_driver_template)
    zigbee_outlet:run()


Class Documentation
~~~~~~~~~~~~~~~~~~~

.. lua:autoclass:: ZigbeeDevice
