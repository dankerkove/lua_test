local cluster_base = require "st.zigbee.cluster_base"
local data_types = require "st.zigbee.data_types"

-- DO NOT EDIT: this code is automatically generated by tools/zigbee-lib_generator/generate_clusters_from_xml.py
-- Script version: b'2cda4a8ebeb3328f48b89dd179d4e8623e7ad8f1'
-- ZCL XML version: 7.2

--- @class st.zigbee.zcl.clusters.BarrierControl.SafetyStatus
--- @alias SafetyStatus
---
--- @field public ID number 0x0002 the ID of this attribute
--- @field public NAME string "SafetyStatus" the name of this attribute
--- @field public data_type Bitmap16 the data type of this attribute
--- @field public REMOTE_LOCKOUT number 1
--- @field public TAMPER_DETECTED number 2
--- @field public FAILED_COMMUNICATION number 4
--- @field public POSITION_FAILURE number 8
local SafetyStatus = {
  ID = 0x0002,
  NAME = "SafetyStatus",
  base_type = data_types.Bitmap16,
}

SafetyStatus.BASE_MASK            = 0xFFFF
SafetyStatus.REMOTE_LOCKOUT       = 0x0001
SafetyStatus.TAMPER_DETECTED      = 0x0002
SafetyStatus.FAILED_COMMUNICATION = 0x0004
SafetyStatus.POSITION_FAILURE     = 0x0008


SafetyStatus.mask_fields = {
  BASE_MASK = 0xFFFF,
  REMOTE_LOCKOUT = 0x0001,
  TAMPER_DETECTED = 0x0002,
  FAILED_COMMUNICATION = 0x0004,
  POSITION_FAILURE = 0x0008,
}


--- @function SafetyStatus:is_remote_lockout_set
--- @return boolean True if the value of REMOTE_LOCKOUT is non-zero
SafetyStatus.is_remote_lockout_set = function(self)
  return (self.value & self.REMOTE_LOCKOUT) ~= 0
end
 
--- @function SafetyStatus:set_remote_lockout
--- Set the value of the bit in the REMOTE_LOCKOUT field to 1
SafetyStatus.set_remote_lockout = function(self)
  self.value = self.value | self.REMOTE_LOCKOUT
end

--- @function SafetyStatus:unset_remote_lockout
--- Set the value of the bits in the REMOTE_LOCKOUT field to 0
SafetyStatus.unset_remote_lockout = function(self)
  self.value = self.value & (~self.REMOTE_LOCKOUT & self.BASE_MASK)
end

--- @function SafetyStatus:is_tamper_detected_set
--- @return boolean True if the value of TAMPER_DETECTED is non-zero
SafetyStatus.is_tamper_detected_set = function(self)
  return (self.value & self.TAMPER_DETECTED) ~= 0
end
 
--- @function SafetyStatus:set_tamper_detected
--- Set the value of the bit in the TAMPER_DETECTED field to 1
SafetyStatus.set_tamper_detected = function(self)
  self.value = self.value | self.TAMPER_DETECTED
end

--- @function SafetyStatus:unset_tamper_detected
--- Set the value of the bits in the TAMPER_DETECTED field to 0
SafetyStatus.unset_tamper_detected = function(self)
  self.value = self.value & (~self.TAMPER_DETECTED & self.BASE_MASK)
end

--- @function SafetyStatus:is_failed_communication_set
--- @return boolean True if the value of FAILED_COMMUNICATION is non-zero
SafetyStatus.is_failed_communication_set = function(self)
  return (self.value & self.FAILED_COMMUNICATION) ~= 0
end
 
--- @function SafetyStatus:set_failed_communication
--- Set the value of the bit in the FAILED_COMMUNICATION field to 1
SafetyStatus.set_failed_communication = function(self)
  self.value = self.value | self.FAILED_COMMUNICATION
end

--- @function SafetyStatus:unset_failed_communication
--- Set the value of the bits in the FAILED_COMMUNICATION field to 0
SafetyStatus.unset_failed_communication = function(self)
  self.value = self.value & (~self.FAILED_COMMUNICATION & self.BASE_MASK)
end

--- @function SafetyStatus:is_position_failure_set
--- @return boolean True if the value of POSITION_FAILURE is non-zero
SafetyStatus.is_position_failure_set = function(self)
  return (self.value & self.POSITION_FAILURE) ~= 0
end
 
--- @function SafetyStatus:set_position_failure
--- Set the value of the bit in the POSITION_FAILURE field to 1
SafetyStatus.set_position_failure = function(self)
  self.value = self.value | self.POSITION_FAILURE
end

--- @function SafetyStatus:unset_position_failure
--- Set the value of the bits in the POSITION_FAILURE field to 0
SafetyStatus.unset_position_failure = function(self)
  self.value = self.value & (~self.POSITION_FAILURE & self.BASE_MASK)
end


SafetyStatus.mask_methods = {
  is_remote_lockout_set = SafetyStatus.is_remote_lockout_set,
  set_remote_lockout = SafetyStatus.set_remote_lockout,
  unset_remote_lockout = SafetyStatus.unset_remote_lockout,
  is_tamper_detected_set = SafetyStatus.is_tamper_detected_set,
  set_tamper_detected = SafetyStatus.set_tamper_detected,
  unset_tamper_detected = SafetyStatus.unset_tamper_detected,
  is_failed_communication_set = SafetyStatus.is_failed_communication_set,
  set_failed_communication = SafetyStatus.set_failed_communication,
  unset_failed_communication = SafetyStatus.unset_failed_communication,
  is_position_failure_set = SafetyStatus.is_position_failure_set,
  set_position_failure = SafetyStatus.set_position_failure,
  unset_position_failure = SafetyStatus.unset_position_failure,
}

--- Add additional functionality to the base type object
---
--- @param base_type_obj Bitmap16 the base data type object to add functionality to
function SafetyStatus:augment_type(base_type_obj)
  for k, v in pairs(self.mask_fields) do
    base_type_obj[k] = v
  end
  for k, v in pairs(self.mask_methods) do
    base_type_obj[k] = v
  end
  
  base_type_obj.field_name = self.NAME
  base_type_obj.pretty_print = self.pretty_print
end

function SafetyStatus.pretty_print(value_obj)
  local zb_utils = require "st.zigbee.utils" 
  local pattern = ">I" .. value_obj.byte_length
  return string.format("%s: %s[0x]", value_obj.field_name or value_obj.NAME, SafetyStatus.NAME, zb_utils.pretty_print_hex_str(string.pack(pattern, value_obj.value)))
end

--- @function SafetyStatus:build_test_attr_report
---
--- Build a Rx Zigbee message as if a device reported this attribute
--- @param device ZigbeeDevice
--- @param data Bitmap16 the attribute value
--- @return ZigbeeMessageRx containing an AttributeReport body
SafetyStatus.build_test_attr_report = cluster_base.build_test_attr_report

--- @function SafetyStatus:build_test_read_attr_response
---
--- Build a Rx Zigbee message as if a device sent a read response for this attribute
--- @param device ZigbeeDevice
--- @param data Bitmap16 the attribute value
--- @return ZigbeeMessageRx containing an ReadAttributeResponse body
SafetyStatus.build_test_read_attr_response = cluster_base.build_test_read_attr_response

--- Create a Bitmap16 object of this attribute with any additional features provided for the attribute
---
--- This is also usable with the SafetyStatus(...) syntax
---
--- @param ... vararg the values needed to construct a Bitmap16
--- @return Bitmap16
function SafetyStatus:new_value(...)
    local o = self.base_type(table.unpack({...}))
    self:augment_type(o)
    return o
end

--- Construct a ZigbeeMessageTx to read this attribute from a device
---
--- @param device ZigbeeDevice
--- @return ZigbeeMessageTx containing a ReadAttribute body
function SafetyStatus:read(device)
    return cluster_base.read_attribute(device, data_types.ClusterId(self._cluster.ID), data_types.AttributeId(self.ID))
end

--- Construct a ZigbeeMessageTx to configure this attribute for reporting on a device
---
--- @param device ZigbeeDevice
--- @param min_rep_int number|Uint16 the minimum interval allowed between reports of this attribute
--- @param max_rep_int number|Uint16 the maximum interval allowed between reports of this attribute
--- @return ZigbeeMessageTx containing a ConfigureReporting body
function SafetyStatus:configure_reporting(device, min_rep_int, max_rep_int)
  local min = data_types.validate_or_build_type(min_rep_int, data_types.Uint16, "minimum_reporting_interval")
  local max = data_types.validate_or_build_type(max_rep_int, data_types.Uint16, "maximum_reporting_interval")
  local rep_change = nil
  return cluster_base.configure_reporting(device, data_types.ClusterId(self._cluster.ID), data_types.AttributeId(self.ID), data_types.ZigbeeDataType(self.base_type.ID), min, max, rep_change)
end

function SafetyStatus:set_parent_cluster(cluster)
  self._cluster = cluster
  return self
end

setmetatable(SafetyStatus, {__call = SafetyStatus.new_value})
return SafetyStatus
