local log = require "log"
local thread = require "st.thread"
local capabilities = require "st.capabilities"
local base64 = require "st.base64"

--- @module device
local device_module = {}

device_module.NETWORK_TYPE_ZIGBEE = "DEVICE_ZIGBEE"
device_module.NETWORK_TYPE_ZWAVE = "DEVICE_ZWAVE"

local function convert_st_store_to_readonly(value)
    if type(value) ~= "table" then
        return value
    end
    local mt = {}
    mt.__values = {}
    mt.__newindex = function(self, key, value)
        error("st_store is for readonly SmartThings info only. Use set_field to add a value to the device.")
    end
    mt.__index = function(self, key)
        return mt.__values[key]
    end
    mt.__pairs = function(self)
        return pairs(mt.__values)
    end

    for k,v in pairs(value) do
        mt.__values[k] = convert_st_store_to_readonly(v)
    end
    local out = {}
    setmetatable(out, mt)
    return out
end

--- @function Device:emit_event
--- Emit a capability event for this devices main component.  Will log a warning and do nothing if there is no "main" component on the device
---
--- @param capability_event table the capability event to emit
local function emit_event(self, capability_event) end

--- @function component:emit_event
--- Emit a capability event for the corresponding component
---
--- @param capability_event table the capability event to emit
local function comp_emit_event(self, capability_event) end

local function convert_and_set_st_store(device, raw_st_store)
    if raw_st_store.zigbee_eui then
        raw_st_store.zigbee_eui = base64.decode(raw_st_store.zigbee_eui)
    end

    -- Build a more natural component structure
    for comp_id, component in pairs(raw_st_store.profile.components) do
        component.emit_event = function(self, capability_event)
            device:emit_component_event(component, capability_event)
        end
    end

    local device_mt = getmetatable(device)

    if raw_st_store.profile.components.main ~= nil then
        device_mt.__values["emit_event"] = raw_st_store.profile.components.main.emit_event
    else
        device_mt.__values["emit_event"] = function(...)
            local err_msg = string.format("Device %s does not have \"main\" component, use component specific event generation", device.id)
            log.warn(err_msg)
            return false, err_msg
        end
    end

    local new_st_store = convert_st_store_to_readonly(raw_st_store)
    device_mt.__values["st_store"] = new_st_store
end

-- Device definition
--- @class Device
---
--- A device object contains all of the information we have about a given device that is set to be managed by this
--- driver.  It also provides a number of utility functions that make normal operations for dealing with devices
--- simpler.
---
--- @field public transient_store table Used to store driver specific data about a device that will not persist through driver restart.
--- @field public persistent_store table Used to store driver specific data about a device that will be persisted through restart.  The actual flash writes are on a schedule so some data loss is possible if the hub experiences a power loss
--- @field public st_store table Contains the SmartThings device model.  Read only and can be updated as a result of changes made elsewhere in the system.
--- @field public state_cache table Caches the most recent event state generated for each component/capability/attribute this is per run session, and is not persisted through restart.
local Device = {}

--- @function Device:emit_component_event
--- Generate a capability event for this device and component
---
--- Usage: ``device:emit_component_event(device.components.main, capabilities.switch.switch.on())``
---
--- @param component table The component to generate this event for
--- @param capability_event table The event table generated from a capability
--- @return table The converted SmartThings event generated by this device
function Device:emit_component_event(component, capability_event)
    if not self:supports_capability(capability_event.capability, component.id) then
        local err_msg = string.format("Attempted to generate event for %s.%s but it does not support capability %s", self.id, component.id, capability_event.capability.NAME)
        log.warn(err_msg)
        return false, err_msg
    end
    local event, err = capabilities.emit_event(self, component.id, self.capability_channel, capability_event)
    if event ~= nil then
        self.state_cache[component.id] = self.state_cache[component.id] or {}
        self.state_cache[component.id][capability_event.capability.ID] = self.state_cache[component.id][capability_event.capability.ID] or {}
        self.state_cache[component.id][capability_event.capability.ID][capability_event.attribute.NAME] = event.state
    end
    if err ~= nil then
        log.warn(err)
    end
    return event, err
end

local function new_device_mt(cls, device_proto)
    local mt = {}
    mt.__values = {}
    mt.__cls = cls

    for k,v in pairs(device_proto) do
        mt.__values[k] = v
    end

    mt.__index = function(self, key)
        local base_value = mt.__values[key]
        local st_store = mt.__values["st_store"]
        if base_value ~= nil then
            return base_value
        elseif type(st_store) == "table" and st_store[key] ~= nil then
            return st_store[key]
        end
        return mt.__cls[key]
    end
    mt.__newindex = function(self, key, value)
        error("Device table access is readonly.  Use set_field to add a new field to the device.")
    end
    mt.__tostring = cls.pretty_print
    return mt
end

--- @function Device:set_field
--- Set a device specific value to be stored and retrieved when needed.  The key names are unique across both persistent and transient stores.
---
--- @param field string The field name for this value
--- @param value value The value to set the field to. If setting to persistent store it must be serializable
--- @param addtional_params table Optional: contains additional description of the field.  Currently only usage is the `persist` field which, if true, will store the field to the persistent store instead of transient
function Device:set_field(field, value, additional_params)
    local persisted = false
    if type(additional_params) == "table" then
        persisted = additional_params["persist"] or false
    elseif type(additional_params) ~= "nil" then
        error("additional_params must be a table")
    end
    -- Clear the old value out if it existed.
    self.transient_store[field] = nil
    self.persistent_store[field] = nil

    -- Set the new value in the corresponding persistence table
    if persisted then
        self.persistent_store[field] = value
    else
        self.transient_store[field] = value
    end
end

--- @function Device:get_field
--- Retrieve the value a previously set field.  nil if non-existent
---
--- @param field string The field name for this value
--- @return value value The value the field was set to.
function Device:get_field(field)
    if self.transient_store[field] ~= nil then
        return self.transient_store[field]
    elseif self.persistent_store[field] ~= nil then
        return self.persistent_store[field]
    end
end

--- @function Device:supports_capability
--- Check if this device has a capability in its profile
---
--- @param capability Capability The capability to check for existence
--- @param component string Optional: The component id to check for capability support.  If nil, any component match will return true
--- @return boolean true if the capability is present in this devices profile
function Device:supports_capability(capability, component)
  return self:supports_capability_by_id(capability.ID, component)
end

--- @function Device:supports_capability_by_id
--- Check if this device has a capability_id in its profile
---
--- @param capability_id string The capability ID to check for existence
--- @param component string Optional: The component id to check for capability support.  If nil, any component match will return true
--- @return boolean true if the capability is present in this devices profile
function Device:supports_capability_by_id(capability_id, component)
    for comp_id, comp in pairs(self.st_store.profile.components) do
        if (component == nil) or (component == comp_id) then
            for cap_id, cap in pairs(comp.capabilities) do
                if cap.id == capability_id then
                    return true
                end
            end
        end
    end
    return false
end

Device.init = function(cls, driver, raw_device)
    local device = {}

    device.capability_channel = driver.capability_channel
    device.device_api = driver.device_api

    device.online = function(self)
        self.device_api.device_online(self)
    end
    device.offline = function(self)
        self.device_api.device_offline(self)
    end

    driver.datastore.__devices_store = driver.datastore.__devices_store or {}
    driver.datastore.__devices_store[raw_device.id] = driver.datastore.__devices_store[raw_device.id] or {}
    device.persistent_store = driver.datastore.__devices_store[raw_device.id]
    device.datastore = driver.datastore

    device.transient_store = {}

    device.state_cache = {}

    device.thread = thread.Thread(driver, raw_device.label)

    local pers_store_mt = getmetatable(device.persistent_store) or {}
    local old_new_index = pers_store_mt.__newindex or rawset
    pers_store_mt.__newindex = function(self, key, value)
        if device.transient_store[key] ~= nil and value ~= nil then
            log.warn("Key: " .. key .. " already exists in the transient store.  Use set_field if you want to move it.")
        else
            old_new_index(self, key, value)
        end
    end

    local trans_store_mt = {}
    trans_store_mt.__newindex = function(self, key, value)
        if device.persistent_store[key] ~= nil and value ~= nil then
            -- TODO: Error?
            log.warn("Key: " .. key .. " already exists in the persistent store.  Use set_field if you want to move it.")
        else
            rawset(self, key, value)
        end
    end
    return device
end

--- @function Device:try_update_metadata
--- Send a request to update the metadata of a device.
---
--- Example usage: ``device:try_update_metadata({profile = "bulb.rgb.v1", vendor_provided_label = "My RGB Bulb"})``
---
--- All metadata fields are type string. Valid metadata fields are:
---
--- For all network types (LAN/ZIGBEE/ZWAVE):
---     profile - profile name defined in the profile .yaml file.
---
--- LAN specific:
---     manufacturer - device manufacturer
---     model - model name of the device
---     vendor_provided_label - device label provided by the manufacturer/vendor
---
--- @param metadata table A table of device metadata
function Device:try_update_metadata(metadata)
    assert(type(metadata) == "table")

    -- extract only keys we know are valid to prevent sending a bunch of garbage over the rpc
    local normalized_metadata = {
        deviceId = self.id,
        profileReference = metadata.profile,
        manufacturer = metadata.manufacturer,
        model = metadata.model,
        vendorProvidedLabel = metadata.vendor_provided_label
    }

    local metadata_json = json.encode(normalized_metadata)
    if metadata_json == nil then
        error("error parsing device metadata", -1)
    end

    return devices.update_device(self.id, metadata_json)
end

Device._protect = function(cls, device)
    local mt = new_device_mt(cls, device)
    setmetatable(device, mt)
end


--- @function Device.build
--- Build a device object from a raw st_store of the SmartThings device model
---
--- @param cls table The Device class
--- @param driver Driver The driver context this device will run under
--- @param raw_device table The SmartThings device model representation, used to populate the st_store and generate
---                         helper event generation functions
--- @return Device The created device
function Device.build(cls, driver, raw_device)

    local device = Device.init(cls, driver, raw_device)

    Device._protect(cls, device)

    -- This is the data synced from the cloud and will be overwritten when data is updated
    device:load_updated_data(raw_device)

    return device
end


--- @function Device:load_updated_data
--- Update the st_store data with newly provided data from the cloud.
function Device:load_updated_data(new_device_data)
    convert_and_set_st_store(self, new_device_data)
    return self
end

--- @function Device:deleted
--- This will do any necessary cleanup if the device is removed.  The device object will not
--- be functional after this call.
function Device:deleted()
    if self.thread then
        self.thread:close()
        self.thread = nil
    end

    self.datastore.__devices_store[self.id] = nil
    local old_id = self.id
    local new_mt = {}
    new_mt.__index = function(s, key)
        log.warn("This device (former ID: " .. old_id .. ") has been deleted, and is no longer usable")
        return nil
    end
    new_mt.__newindex = function(s, key, value)
        log.warn("This device (former ID: " .. old_id .. ") has been deleted, and is no longer usable")
        return nil
    end
    setmetatable(self, new_mt)
end
Device.CLASS_NAME = "Device"
--- @function Device:pretty_print
--- Get a string with the ID and label of the device
---
--- @return string a short string representation of the device
function Device:pretty_print()
    local label_str = ""
    if self.label ~= nil then
        label_str = string.format("(%s)", self.label)
    end
    return string.format("<%s: %s%s>", self.CLASS_NAME, self.id, label_str)
end

setmetatable(Device, {
    __call = Device.build
})
device_module.Device = Device

return device_module
